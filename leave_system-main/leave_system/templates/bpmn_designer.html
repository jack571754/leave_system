<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BPMN æµç¨‹è®¾è®¡å™¨</title>
    
    <!-- LogicFlow æ ¸å¿ƒåº“ -->
    <script src="/static/logicflow/logic-flow.js"></script>
    <link rel="stylesheet" href="/static/logicflow/style/index.css">
    
    <!-- LogicFlow BPMN æ‰©å±• -->
    <script src="/static/logicflow/extension/BpmnElement.js"></script>
    <script src="/static/logicflow/extension/BpmnAdapter.js"></script>
    
    <!-- CodeMirror ä»£ç ç¼–è¾‘å™¨ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .btn-primary {
            background: white;
            color: #667eea;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,255,255,0.3);
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 60px);
        }
        
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .sidebar-section:last-child {
            flex: 1;
            border-bottom: none;
        }
        
        .sidebar h3 {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .node-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: move;
            transition: all 0.3s;
            font-size: 13px;
            user-select: none;
        }
        
        .node-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }
        
        .process-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .process-item:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }
        
        .process-item.active {
            background: #e7e9fc;
            border-color: #667eea;
        }
        
        .process-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .process-actions {
            display: flex;
            gap: 5px;
        }
        
        .icon-btn {
            padding: 4px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 3px;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .icon-btn:hover {
            background: #e0e0e0;
        }
        
        .icon-btn.delete:hover {
            background: #fee;
            color: #f44;
        }
        
        .add-btn {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .add-btn:hover {
            background: #5568d3;
        }
        
        .empty-list {
            text-align: center;
            padding: 20px;
            color: #999;
            font-size: 12px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        .properties-panel {
            width: 400px;
            background: #2d2d2d;
            color: #e0e0e0;
            overflow-y: auto;
            border-left: 1px solid #444;
        }
        
        .properties-header {
            padding: 15px 20px;
            background: #1e1e1e;
            border-bottom: 1px solid #444;
        }
        
        .properties-header h2 {
            font-size: 16px;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .properties-content {
            padding: 20px;
        }
        
        .property-group {
            margin-bottom: 25px;
        }
        
        .property-group h3 {
            font-size: 14px;
            color: #fff;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }
        
        .property-item {
            margin-bottom: 15px;
        }
        
        .property-label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .property-input {
            width: 100%;
            padding: 8px 12px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .code-editor {
            margin-top: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .CodeMirror {
            height: 200px;
            font-size: 13px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ¨ BPMN æµç¨‹è®¾è®¡å™¨</h1>
        <div class="header-actions">
            <button class="btn btn-success" onclick="saveDiagram()">ğŸ’¾ ä¿å­˜</button>
            <button class="btn btn-primary" onclick="viewXML()">ğŸ“„ æŸ¥çœ‹XML</button>
            <button class="btn btn-primary" onclick="downloadJSON()">â¬‡ï¸ å¯¼å‡ºJSON</button>
            <button class="btn btn-secondary" onclick="window.location.href='/dashboard/'">ğŸ  è¿”å›</button>
        </div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-section">
                <h3>
                    å†å²æµç¨‹
                    <button class="add-btn" onclick="createNewProcess()">+ æ–°å»º</button>
                </h3>
                <div id="process-list">
                    <div class="empty-list">åŠ è½½ä¸­...</div>
                </div>
            </div>
            <div class="sidebar-section">
                <h3>BPMN èŠ‚ç‚¹</h3>
                <div class="node-item" draggable="true" data-type="bpmn:startEvent">
                    â­• å¼€å§‹äº‹ä»¶
                </div>
                <div class="node-item" draggable="true" data-type="bpmn:endEvent">
                    â­• ç»“æŸäº‹ä»¶
                </div>
                <div class="node-item" draggable="true" data-type="bpmn:userTask">
                    ğŸ“‹ ç”¨æˆ·ä»»åŠ¡
                </div>
                <div class="node-item" draggable="true" data-type="bpmn:serviceTask">
                    âš™ï¸ æœåŠ¡ä»»åŠ¡
                </div>
                <div class="node-item" draggable="true" data-type="bpmn:exclusiveGateway">
                    ğŸ”€ æ’ä»–ç½‘å…³
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
        
        <div class="properties-panel">
            <div class="properties-header">
                <h2 id="element-name">å±æ€§é¢æ¿</h2>
            </div>
            <div class="properties-content" id="properties-content">
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“‹</div>
                    <p>é€‰æ‹©ç”»å¸ƒä¸Šçš„å…ƒç´ <br>æŸ¥çœ‹å’Œç¼–è¾‘å±æ€§</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let lf = null;
        let currentElement = null;
        let codeEditors = {};
        let currentProcessId = null;
        let processList = [];

        // åˆå§‹åŒ– LogicFlow
        function initLogicFlow() {
            if (!window.LogicFlow) {
                console.error('LogicFlow åº“æœªåŠ è½½');
                alert('LogicFlow åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢');
                return;
            }

            if (!window.BpmnElement || !window.BpmnAdapter) {
                console.error('BPMN æ’ä»¶æœªåŠ è½½');
                alert('BPMN æ’ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„');
                return;
            }

            const { LogicFlow } = window;
            
            // åˆ›å»º LogicFlow å®ä¾‹
            lf = new LogicFlow({
                container: document.getElementById('canvas'),
                grid: {
                    size: 20,
                    visible: true,
                    type: 'dot',
                    config: {
                        color: '#e0e0e0',
                        thickness: 1,
                    }
                },
                keyboard: {
                    enabled: true,
                },
                edgeTextDraggable: false,
                nodeTextDraggable: false,
                adjustEdge: false,
                hoverOutline: false,
                plugins: [window.BpmnElement, window.BpmnAdapter]
            });
            
            // ç›‘å¬èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
            lf.on('node:click', ({ data }) => {
                currentElement = data;
                showProperties(data);
            });
            
            // ç›‘å¬è¾¹ç‚¹å‡»äº‹ä»¶
            lf.on('edge:click', ({ data }) => {
                currentElement = data;
                showEdgeProperties(data);
            });
            
            // ç›‘å¬ç”»å¸ƒç‚¹å‡»äº‹ä»¶
            lf.on('blank:click', () => {
                currentElement = null;
                showEmptyState();
            });
            
            // ç›‘å¬èŠ‚ç‚¹æ‹–åŠ¨ï¼Œå¼ºåˆ¶æ›´æ–°æ–‡å­—ä½ç½®
            lf.on('node:dnd-drag', ({ data }) => {
                const nodeModel = lf.graphModel.getNodeModelById(data.id);
                if (nodeModel && nodeModel.text && typeof nodeModel.text.value === 'string') {
                    nodeModel.text.x = data.x;
                    nodeModel.text.y = data.y + 40;
                }
            });
            
            // ç›‘å¬èŠ‚ç‚¹æ‹–åŠ¨ç»“æŸ
            lf.on('node:drop', ({ data }) => {
                const nodeModel = lf.graphModel.getNodeModelById(data.id);
                if (nodeModel && nodeModel.text && typeof nodeModel.text.value === 'string') {
                    nodeModel.text.x = data.x;
                    nodeModel.text.y = data.y + 40;
                }
            });
            
            // è®¾ç½®æ‹–æ‹½
            setupDragAndDrop();
            
            // åŠ è½½æµç¨‹åˆ—è¡¨
            loadProcessList();
        }
        
        // è®¾ç½®æ‹–æ‹½åŠŸèƒ½ï¼ˆä¼˜åŒ–æµç•…åº¦ï¼‰
        function setupDragAndDrop() {
            const nodeItems = document.querySelectorAll('.node-item');
            let draggedType = null;
            
            nodeItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedType = e.target.getAttribute('data-type');
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', draggedType);
                    e.target.style.opacity = '0.5';
                });
                
                item.addEventListener('dragend', (e) => {
                    e.target.style.opacity = '1';
                });
            });
            
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });
            
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                
                if (draggedType && lf) {
                    const point = lf.getPointByClient(e.clientX, e.clientY);
                    lf.addNode({
                        type: draggedType,
                        x: point.x,
                        y: point.y,
                        text: getNodeDefaultText(draggedType),
                        properties: {}
                    });
                }
                draggedType = null;
            });
        }
        
        // è·å–èŠ‚ç‚¹é»˜è®¤æ–‡æœ¬
        function getNodeDefaultText(type) {
            const textMap = {
                'bpmn:startEvent': 'å¼€å§‹',
                'bpmn:endEvent': 'ç»“æŸ',
                'bpmn:userTask': 'ç”¨æˆ·ä»»åŠ¡',
                'bpmn:serviceTask': 'æœåŠ¡ä»»åŠ¡',
                'bpmn:exclusiveGateway': 'ç½‘å…³'
            };
            return textMap[type] || '';
        }
        
        // æ¸²æŸ“åˆå§‹å›¾è¡¨
        function renderInitialGraph() {
            const graphData = {
                nodes: [
                    {
                        id: 'start-1',
                        type: 'bpmn:startEvent',
                        x: 200,
                        y: 200,
                        text: 'å¼€å§‹',
                        properties: {
                            name: 'å¼€å§‹èŠ‚ç‚¹'
                        }
                    },
                    {
                        id: 'task-1',
                        type: 'bpmn:userTask',
                        x: 400,
                        y: 200,
                        text: 'ç”¨æˆ·ä»»åŠ¡',
                        properties: {
                            name: 'ç”¨æˆ·ä»»åŠ¡',
                            formSchema: '',
                            preScript: '',
                            postScript: ''
                        }
                    },
                    {
                        id: 'end-1',
                        type: 'bpmn:endEvent',
                        x: 600,
                        y: 200,
                        text: 'ç»“æŸ',
                        properties: {
                            name: 'ç»“æŸèŠ‚ç‚¹'
                        }
                    }
                ],
                edges: [
                    {
                        id: 'edge-1',
                        type: 'bpmn:sequenceFlow',
                        sourceNodeId: 'start-1',
                        targetNodeId: 'task-1',
                        text: '',
                        properties: {
                            condition: ''
                        }
                    },
                    {
                        id: 'edge-2',
                        type: 'bpmn:sequenceFlow',
                        sourceNodeId: 'task-1',
                        targetNodeId: 'end-1',
                        text: '',
                        properties: {
                            condition: ''
                        }
                    }
                ]
            };
            
            lf.render(graphData);
        }
        
        // æ˜¾ç¤ºèŠ‚ç‚¹å±æ€§
        function showProperties(node) {
            document.getElementById('element-name').textContent = node.text || node.id;
            
            const props = node.properties || {};
            let html = `
                <div class="property-group">
                    <h3>åŸºæœ¬å±æ€§</h3>
                    <div class="property-item">
                        <label class="property-label">ID</label>
                        <input type="text" class="property-input" value="${node.id}" readonly>
                    </div>
                    <div class="property-item">
                        <label class="property-label">åç§°</label>
                        <input type="text" class="property-input" id="prop-name" value="${node.text || ''}" 
                               onchange="updateNodeProperty('text', this.value)">
                    </div>
                    <div class="property-item">
                        <label class="property-label">èŠ‚ç‚¹ç±»å‹</label>
                        <input type="text" class="property-input" value="${node.type}" readonly>
                    </div>
                </div>
            `;
            
            // ç”¨æˆ·ä»»åŠ¡ç‰¹å®šå±æ€§
            if (node.type === 'bpmn:userTask' || node.type === 'bpmn:serviceTask') {
                html += `
                    <div class="property-group">
                        <h3>è¡¨å•é…ç½®</h3>
                        <div class="property-item">
                            <label class="property-label">è¡¨å• Schema æ–‡ä»¶</label>
                            <input type="text" class="property-input" id="prop-form-schema" 
                                   value="${props.formSchema || ''}"
                                   onchange="updateNodeProperty('formSchema', this.value)">
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <h3>å‰ç½®è„šæœ¬ (Python)</h3>
                        <div class="property-item">
                            <label class="property-label">åœ¨ä»»åŠ¡æ‰§è¡Œå‰è¿è¡Œ</label>
                            <div class="code-editor">
                                <textarea id="pre-script-editor">${props.preScript || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <h3>åç½®è„šæœ¬ (Python)</h3>
                        <div class="property-item">
                            <label class="property-label">åœ¨ä»»åŠ¡å®Œæˆåè¿è¡Œ</label>
                            <div class="code-editor">
                                <textarea id="post-script-editor">${props.postScript || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('properties-content').innerHTML = html;
            
            // åˆå§‹åŒ–ä»£ç ç¼–è¾‘å™¨
            setTimeout(() => {
                if (document.getElementById('pre-script-editor')) {
                    initCodeEditor('pre-script-editor', 'python', (value) => {
                        updateNodeProperty('preScript', value);
                    });
                }
                if (document.getElementById('post-script-editor')) {
                    initCodeEditor('post-script-editor', 'python', (value) => {
                        updateNodeProperty('postScript', value);
                    });
                }
            }, 100);
        }
        
        // æ˜¾ç¤ºè¾¹å±æ€§
        function showEdgeProperties(edge) {
            document.getElementById('element-name').textContent = 'è¿çº¿å±æ€§';
            
            const props = edge.properties || {};
            const html = `
                <div class="property-group">
                    <h3>åŸºæœ¬å±æ€§</h3>
                    <div class="property-item">
                        <label class="property-label">ID</label>
                        <input type="text" class="property-input" value="${edge.id}" readonly>
                    </div>
                    <div class="property-item">
                        <label class="property-label">æ–‡æœ¬</label>
                        <input type="text" class="property-input" id="prop-edge-text" value="${edge.text || ''}" 
                               onchange="updateEdgeProperty('text', this.value)">
                    </div>
                </div>
                
                <div class="property-group">
                    <h3>æ¡ä»¶è¡¨è¾¾å¼ (Python)</h3>
                    <div class="property-item">
                        <label class="property-label">æµè½¬æ¡ä»¶</label>
                        <div class="code-editor">
                            <textarea id="condition-editor">${props.condition || ''}</textarea>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('properties-content').innerHTML = html;
            
            // åˆå§‹åŒ–ä»£ç ç¼–è¾‘å™¨
            setTimeout(() => {
                if (document.getElementById('condition-editor')) {
                    initCodeEditor('condition-editor', 'python', (value) => {
                        updateEdgeProperty('condition', value);
                    });
                }
            }, 100);
        }
        
        // æ˜¾ç¤ºç©ºçŠ¶æ€
        function showEmptyState() {
            document.getElementById('element-name').textContent = 'å±æ€§é¢æ¿';
            document.getElementById('properties-content').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“‹</div>
                    <p>é€‰æ‹©ç”»å¸ƒä¸Šçš„å…ƒç´ <br>æŸ¥çœ‹å’Œç¼–è¾‘å±æ€§</p>
                </div>
            `;
        }
        
        // åˆå§‹åŒ–ä»£ç ç¼–è¾‘å™¨
        function initCodeEditor(elementId, mode, onChange) {
            const textarea = document.getElementById(elementId);
            if (!textarea) return;
            
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: mode,
                theme: 'monokai',
                lineNumbers: true,
                lineWrapping: true,
                indentUnit: 4,
                tabSize: 4,
                indentWithTabs: false,
                autoCloseBrackets: true,
                matchBrackets: true
            });
            
            editor.on('change', function() {
                if (onChange) {
                    onChange(editor.getValue());
                }
            });
            
            codeEditors[elementId] = editor;
        }
        
        // æ›´æ–°èŠ‚ç‚¹å±æ€§
        function updateNodeProperty(property, value) {
            if (!currentElement) return;
            
            if (property === 'text') {
                lf.setProperties(currentElement.id, { ...currentElement.properties });
                lf.updateText(currentElement.id, value);
            } else {
                const newProperties = { ...currentElement.properties, [property]: value };
                lf.setProperties(currentElement.id, newProperties);
                currentElement.properties = newProperties;
            }
        }
        
        // æ›´æ–°è¾¹å±æ€§
        function updateEdgeProperty(property, value) {
            if (!currentElement) return;
            
            if (property === 'text') {
                lf.updateText(currentElement.id, value);
            } else {
                const newProperties = { ...currentElement.properties, [property]: value };
                lf.setProperties(currentElement.id, newProperties);
                currentElement.properties = newProperties;
            }
        }
        
        // ä¿å­˜å›¾è¡¨
        function saveDiagram() {
            const graphData = lf.getGraphData();
            console.log('ä¿å­˜çš„å›¾è¡¨æ•°æ®:', graphData);
            
            fetch('/api/bpmn/save/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(graphData)
            })
            .then(response => response.json())
            .then(data => {
                alert('ä¿å­˜æˆåŠŸï¼');
            })
            .catch(error => {
                console.error('ä¿å­˜å¤±è´¥:', error);
                alert('ä¿å­˜å¤±è´¥: ' + error.message);
            });
        }
        
        // æŸ¥çœ‹ XML
        function viewXML() {
            if (!lf) {
                alert('æµç¨‹è®¾è®¡å™¨æœªåˆå§‹åŒ–');
                return;
            }
            const graphData = lf.getGraphData();
            if (!graphData || (!graphData.nodes && !graphData.edges)) {
                alert('å½“å‰ç”»å¸ƒä¸ºç©ºï¼Œæ— æ³•ç”ŸæˆXML');
                return;
            }
            const xmlContent = generateBPMNXML(graphData);
            
            // åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºXML
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:9999;display:flex;align-items:center;justify-content:center;';
            
            const content = document.createElement('div');
            content.style.cssText = 'background:#2d2d2d;width:80%;height:80%;border-radius:8px;display:flex;flex-direction:column;';
            
            const header = document.createElement('div');
            header.style.cssText = 'padding:15px 20px;background:#1e1e1e;border-bottom:1px solid #444;display:flex;justify-content:space-between;align-items:center;border-radius:8px 8px 0 0;';
            header.innerHTML = '<h3 style="margin:0;color:#fff;">BPMN XML</h3><button onclick="this.closest(\'div[style*=fixed]\').remove()" style="background:#667eea;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">å…³é—­</button>';
            
            const editorDiv = document.createElement('div');
            editorDiv.style.cssText = 'flex:1;overflow:hidden;';
            const textarea = document.createElement('textarea');
            textarea.value = xmlContent;
            editorDiv.appendChild(textarea);
            
            content.appendChild(header);
            content.appendChild(editorDiv);
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // åˆå§‹åŒ–ä»£ç ç¼–è¾‘å™¨
            setTimeout(() => {
                const editor = CodeMirror.fromTextArea(textarea, {
                    mode: 'xml',
                    theme: 'monokai',
                    lineNumbers: true,
                    readOnly: true,
                    lineWrapping: true
                });
                editor.setSize('100%', '100%');
            }, 100);
        }
        
        // ç”ŸæˆBPMN XML
        function generateBPMNXML(graphData) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI">\n';
            xml += '  <bpmn:process id="Process_1" isExecutable="true">\n';
            
            if (graphData.nodes && graphData.nodes.length > 0) {
                graphData.nodes.forEach(node => {
                    const nodeType = node.type.split(':')[1];
                    xml += `    <bpmn:${nodeType} id="${node.id}" name="${node.text || ''}">\n`;
                    if (node.properties) {
                        Object.entries(node.properties).forEach(([key, value]) => {
                            if (value) xml += `      <bpmn:extensionElements><property name="${key}">${value}</property></bpmn:extensionElements>\n`;
                        });
                    }
                    xml += `    </bpmn:${nodeType}>\n`;
                });
            }
            
            if (graphData.edges && graphData.edges.length > 0) {
                graphData.edges.forEach(edge => {
                    xml += `    <bpmn:sequenceFlow id="${edge.id}" sourceRef="${edge.sourceNodeId}" targetRef="${edge.targetNodeId}"`;
                    if (edge.text) xml += ` name="${edge.text}"`;
                    xml += ' />\n';
                });
            }
            
            xml += '  </bpmn:process>\n';
            xml += '</bpmn:definitions>';
            return xml;
        }
        
        // ä¸‹è½½ JSON
        function downloadJSON() {
            const graphData = lf.getGraphData();
            const dataStr = JSON.stringify(graphData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'bpmn-flow-' + Date.now() + '.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        // åŠ è½½æµç¨‹åˆ—è¡¨
        function loadProcessList() {
            fetch('/api/bpmn/processes/')
                .then(response => response.json())
                .then(data => {
                    processList = data.processes || [];
                    renderProcessList();
                    if (processList.length > 0) {
                        loadProcess(processList[0].id);
                    } else {
                        renderInitialGraph();
                    }
                })
                .catch(error => {
                    console.error('åŠ è½½æµç¨‹åˆ—è¡¨å¤±è´¥:', error);
                    document.getElementById('process-list').innerHTML = '<div class="empty-list">åŠ è½½å¤±è´¥</div>';
                    renderInitialGraph();
                });
        }
        
        // æ¸²æŸ“æµç¨‹åˆ—è¡¨
        function renderProcessList() {
            const listEl = document.getElementById('process-list');
            if (processList.length === 0) {
                listEl.innerHTML = '<div class="empty-list">æš‚æ— æµç¨‹</div>';
                return;
            }
            
            listEl.innerHTML = processList.map(process => `
                <div class="process-item ${process.id === currentProcessId ? 'active' : ''}" onclick="loadProcess('${process.id}')">
                    <span class="process-name" title="${process.name}">${process.name}</span>
                    <div class="process-actions">
                        <button class="icon-btn delete" onclick="event.stopPropagation();deleteProcess('${process.id}')" title="åˆ é™¤">ğŸ—‘ï¸</button>
                    </div>
                </div>
            `).join('');
        }
        
        // è‡ªå®šä¹‰BPMNè§£æå‡½æ•°
        function parseSpiffBPMN(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
            
            const nodes = [];
            const edges = [];
            
            // è§£æèŠ‚ç‚¹
            const process = xmlDoc.querySelector('process');
            if (!process) return { nodes, edges };
            
            // è§£æå¼€å§‹äº‹ä»¶
            process.querySelectorAll('startEvent').forEach(node => {
                const shape = xmlDoc.querySelector(`BPMNShape[bpmnElement="${node.id}"]`);
                if (shape) {
                    const bounds = shape.querySelector('Bounds');
                    nodes.push({
                        id: node.id,
                        type: 'bpmn:startEvent',
                        x: parseFloat(bounds.getAttribute('x')) + parseFloat(bounds.getAttribute('width')) / 2,
                        y: parseFloat(bounds.getAttribute('y')) + parseFloat(bounds.getAttribute('height')) / 2,
                        text: node.getAttribute('name') || 'å¼€å§‹',
                        properties: {}
                    });
                }
            });
            
            // è§£æç”¨æˆ·ä»»åŠ¡
            process.querySelectorAll('userTask').forEach(node => {
                const shape = xmlDoc.querySelector(`BPMNShape[bpmnElement="${node.id}"]`);
                if (shape) {
                    const bounds = shape.querySelector('Bounds');
                    const props = {};
                    node.querySelectorAll('property').forEach(prop => {
                        props[prop.getAttribute('name')] = prop.textContent;
                    });
                    nodes.push({
                        id: node.id,
                        type: 'bpmn:userTask',
                        x: parseFloat(bounds.getAttribute('x')) + parseFloat(bounds.getAttribute('width')) / 2,
                        y: parseFloat(bounds.getAttribute('y')) + parseFloat(bounds.getAttribute('height')) / 2,
                        text: node.getAttribute('name') || 'ç”¨æˆ·ä»»åŠ¡',
                        properties: props
                    });
                }
            });
            
            // è§£ææœåŠ¡ä»»åŠ¡
            process.querySelectorAll('serviceTask').forEach(node => {
                const shape = xmlDoc.querySelector(`BPMNShape[bpmnElement="${node.id}"]`);
                if (shape) {
                    const bounds = shape.querySelector('Bounds');
                    nodes.push({
                        id: node.id,
                        type: 'bpmn:serviceTask',
                        x: parseFloat(bounds.getAttribute('x')) + parseFloat(bounds.getAttribute('width')) / 2,
                        y: parseFloat(bounds.getAttribute('y')) + parseFloat(bounds.getAttribute('height')) / 2,
                        text: node.getAttribute('name') || 'æœåŠ¡ä»»åŠ¡',
                        properties: {}
                    });
                }
            });
            
            // è§£æç½‘å…³
            process.querySelectorAll('exclusiveGateway').forEach(node => {
                const shape = xmlDoc.querySelector(`BPMNShape[bpmnElement="${node.id}"]`);
                if (shape) {
                    const bounds = shape.querySelector('Bounds');
                    nodes.push({
                        id: node.id,
                        type: 'bpmn:exclusiveGateway',
                        x: parseFloat(bounds.getAttribute('x')) + parseFloat(bounds.getAttribute('width')) / 2,
                        y: parseFloat(bounds.getAttribute('y')) + parseFloat(bounds.getAttribute('height')) / 2,
                        text: node.getAttribute('name') || 'ç½‘å…³',
                        properties: {}
                    });
                }
            });
            
            // è§£æç»“æŸäº‹ä»¶
            process.querySelectorAll('endEvent').forEach(node => {
                const shape = xmlDoc.querySelector(`BPMNShape[bpmnElement="${node.id}"]`);
                if (shape) {
                    const bounds = shape.querySelector('Bounds');
                    nodes.push({
                        id: node.id,
                        type: 'bpmn:endEvent',
                        x: parseFloat(bounds.getAttribute('x')) + parseFloat(bounds.getAttribute('width')) / 2,
                        y: parseFloat(bounds.getAttribute('y')) + parseFloat(bounds.getAttribute('height')) / 2,
                        text: node.getAttribute('name') || 'ç»“æŸ',
                        properties: {}
                    });
                }
            });
            
            // è§£æè¿çº¿
            process.querySelectorAll('sequenceFlow').forEach(edge => {
                const edgeEl = xmlDoc.querySelector(`BPMNEdge[bpmnElement="${edge.id}"]`);
                if (edgeEl) {
                    const waypoints = Array.from(edgeEl.querySelectorAll('waypoint')).map(wp => ({
                        x: parseFloat(wp.getAttribute('x')),
                        y: parseFloat(wp.getAttribute('y'))
                    }));
                    edges.push({
                        id: edge.id,
                        type: 'bpmn:sequenceFlow',
                        sourceNodeId: edge.getAttribute('sourceRef'),
                        targetNodeId: edge.getAttribute('targetRef'),
                        text: edge.getAttribute('name') || '',
                        properties: {},
                        pointsList: waypoints
                    });
                }
            });
            
            return { nodes, edges };
        }
        
        // åŠ è½½æµç¨‹
        function loadProcess(processId) {
            currentProcessId = processId;
            fetch(`/api/bpmn/processes/${processId}/`)
                .then(response => response.json())
                .then(data => {
                    if (data.xml) {
                        try {
                            const customData = parseSpiffBPMN(data.xml);
                            console.log('è§£æçš„èŠ‚ç‚¹:', customData.nodes);
                            console.log('è§£æçš„è¿çº¿:', customData.edges);
                            
                            if (customData.nodes.length > 0) {
                                lf.render(customData);
                            } else {
                                console.error('æœªèƒ½è§£æå‡ºèŠ‚ç‚¹');
                                renderInitialGraph();
                            }
                        } catch (e) {
                            console.error('è§£æBPMNå¤±è´¥:', e);
                            renderInitialGraph();
                        }
                    } else {
                        renderInitialGraph();
                    }
                    renderProcessList();
                })
                .catch(error => {
                    console.error('åŠ è½½æµç¨‹å¤±è´¥:', error);
                    alert('åŠ è½½æµç¨‹å¤±è´¥: ' + error.message);
                });
        }
        
        // åˆ é™¤æµç¨‹
        function deleteProcess(processId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæµç¨‹å—ï¼Ÿ')) return;
            
            fetch(`/api/bpmn/processes/${processId}/`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                alert('åˆ é™¤æˆåŠŸ');
                loadProcessList();
            })
            .catch(error => {
                console.error('åˆ é™¤å¤±è´¥:', error);
                alert('åˆ é™¤å¤±è´¥: ' + error.message);
            });
        }
        
        // åˆ›å»ºæ–°æµç¨‹
        function createNewProcess() {
            const name = prompt('è¯·è¾“å…¥æµç¨‹åç§°:');
            if (!name) return;
            
            const graphData = lf.getGraphData();
            const xml = generateBPMNXML(graphData);
            
            fetch('/api/bpmn/processes/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    description: '',
                    group: 'custom',
                    xml: xml
                })
            })
            .then(response => response.json())
            .then(data => {
                alert('åˆ›å»ºæˆåŠŸ');
                loadProcessList();
            })
            .catch(error => {
                console.error('åˆ›å»ºå¤±è´¥:', error);
                alert('åˆ›å»ºå¤±è´¥: ' + error.message);
            });
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            initLogicFlow();
        });
    </script>
</body>
</html>
